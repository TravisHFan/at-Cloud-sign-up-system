/**
 * LockService Test Suite
 * Comprehensive tests for application-level locking and thread safety
 * Following Phase 3.1 patterns established with UserDeletionService, ImageCompressionService, and LoggerService
 */

import { describe, expect, it, vi, beforeEach, afterEach } from "vitest";
import {
  InMemoryLockService,
  ILockService,
  lockService,
} from "../../../src/services/LockService";

describe("LockService", () => {
  let testLockService: InMemoryLockService;

  beforeEach(() => {
    // Create fresh lock service instance for clean tests
    testLockService = new InMemoryLockService();
  });

  afterEach(() => {
    vi.clearAllMocks();
    vi.restoreAllMocks();
  });

  describe("Interface Compliance", () => {
    it("should implement ILockService interface", () => {
      const lockServiceInstance: ILockService = testLockService;

      expect(typeof lockServiceInstance.withLock).toBe("function");
      expect(typeof lockServiceInstance.getLockStats).toBe("function");
    });
  });

  describe("Basic Lock Operations", () => {
    it("should execute operation without lock when no contention", async () => {
      const mockOperation = vi.fn().mockResolvedValue("success");

      const result = await testLockService.withLock("test-key", mockOperation);

      expect(result).toBe("success");
      expect(mockOperation).toHaveBeenCalledTimes(1);
    });

    it("should execute multiple operations with different lock keys concurrently", async () => {
      const operation1 = vi.fn().mockResolvedValue("result1");
      const operation2 = vi.fn().mockResolvedValue("result2");

      const [result1, result2] = await Promise.all([
        testLockService.withLock("key1", operation1),
        testLockService.withLock("key2", operation2),
      ]);

      expect(result1).toBe("result1");
      expect(result2).toBe("result2");
      expect(operation1).toHaveBeenCalledTimes(1);
      expect(operation2).toHaveBeenCalledTimes(1);
    });

    it("should handle operations that return different data types", async () => {
      const numberOperation = vi.fn().mockResolvedValue(42);
      const objectOperation = vi.fn().mockResolvedValue({ data: "test" });
      const arrayOperation = vi.fn().mockResolvedValue([1, 2, 3]);

      const numberResult = await testLockService.withLock(
        "num",
        numberOperation
      );
      const objectResult = await testLockService.withLock(
        "obj",
        objectOperation
      );
      const arrayResult = await testLockService.withLock("arr", arrayOperation);

      expect(numberResult).toBe(42);
      expect(objectResult).toEqual({ data: "test" });
      expect(arrayResult).toEqual([1, 2, 3]);
    });
  });

  describe("Lock Contention and Serialization", () => {
    it("should serialize operations with the same lock key", async () => {
      const executionOrder: number[] = [];

      const operation1 = vi.fn().mockImplementation(async () => {
        executionOrder.push(1);
        await new Promise((resolve) => setTimeout(resolve, 5));
        executionOrder.push(2);
        return "first";
      });

      const operation2 = vi.fn().mockImplementation(async () => {
        executionOrder.push(3);
        await new Promise((resolve) => setTimeout(resolve, 5));
        executionOrder.push(4);
        return "second";
      });

      // Start both operations simultaneously with same lock key
      const promise1 = testLockService.withLock("same-key", operation1);
      const promise2 = testLockService.withLock("same-key", operation2);

      const [result1, result2] = await Promise.all([promise1, promise2]);

      expect(result1).toBe("first");
      expect(result2).toBe("second");
      // First operation should complete entirely before second starts
      expect(executionOrder).toEqual([1, 2, 3, 4]);
    }, 15000); // 15 second timeout

    it("should handle multiple operations queued on same lock", async () => {
      const executionOrder: string[] = [];

      const createOperation = (id: string, delay: number) =>
        vi.fn().mockImplementation(async () => {
          executionOrder.push(`start-${id}`);
          await new Promise((resolve) => setTimeout(resolve, delay));
          executionOrder.push(`end-${id}`);
          return id;
        });

      const op1 = createOperation("A", 5);
      const op2 = createOperation("B", 5);
      const op3 = createOperation("C", 5);

      // Start all operations simultaneously with same lock key
      const promises = [
        testLockService.withLock("queue-key", op1),
        testLockService.withLock("queue-key", op2),
        testLockService.withLock("queue-key", op3),
      ];

      const results = await Promise.all(promises);

      expect(results).toEqual(["A", "B", "C"]);
      // Operations should execute sequentially - each should start after previous ends
      expect(executionOrder).toContain("start-A");
      expect(executionOrder).toContain("end-A");
      expect(executionOrder).toContain("start-B");
      expect(executionOrder).toContain("end-B");
      expect(executionOrder).toContain("start-C");
      expect(executionOrder).toContain("end-C");
      // Verify all operations completed
      expect(executionOrder).toHaveLength(6);

      // Verify operations don't overlap (each completes before next starts)
      const aStart = executionOrder.indexOf("start-A");
      const aEnd = executionOrder.indexOf("end-A");
      const bStart = executionOrder.indexOf("start-B");
      expect(aEnd).toBeLessThan(bStart); // A must end before B starts
    }, 15000); // 15 second timeout
  });

  describe("Error Handling", () => {
    it("should propagate errors from failed operations", async () => {
      const errorOperation = vi
        .fn()
        .mockRejectedValue(new Error("Operation failed"));

      await expect(
        testLockService.withLock("error-key", errorOperation)
      ).rejects.toThrow("Operation failed");

      expect(errorOperation).toHaveBeenCalledTimes(1);
    });

    it("should clean up locks after operation errors", async () => {
      const errorOperation = vi.fn().mockRejectedValue(new Error("Test error"));

      try {
        await testLockService.withLock("cleanup-key", errorOperation);
      } catch {
        // Ignore error for this test
      }

      // Lock should be cleaned up, allowing new operations
      const successOperation = vi.fn().mockResolvedValue("success");
      const result = await testLockService.withLock(
        "cleanup-key",
        successOperation
      );

      expect(result).toBe("success");
      expect(successOperation).toHaveBeenCalledTimes(1);
    });

    it("should handle errors in first operation and allow subsequent operations", async () => {
      const failingOperation = vi
        .fn()
        .mockRejectedValue(new Error("First fails"));
      const successOperation = vi.fn().mockResolvedValue("success");

      // First operation fails
      await expect(
        testLockService.withLock("mixed-key", failingOperation)
      ).rejects.toThrow("First fails");

      // Second operation should succeed
      const result = await testLockService.withLock(
        "mixed-key",
        successOperation
      );
      expect(result).toBe("success");
    });

    it("should not affect other locks when one operation fails", async () => {
      const failingOperation = vi.fn().mockRejectedValue(new Error("Fails"));
      const successOperation = vi.fn().mockResolvedValue("success");

      const promises = [
        testLockService
          .withLock("fail-key", failingOperation)
          .catch(() => "caught"),
        testLockService.withLock("success-key", successOperation),
      ];

      const [failResult, successResult] = await Promise.all(promises);

      expect(failResult).toBe("caught");
      expect(successResult).toBe("success");
    });
  });

  describe("Timeout Handling", () => {
    it("should timeout when lock is held too long", async () => {
      const longOperation = vi
        .fn()
        .mockImplementation(
          () => new Promise((resolve) => setTimeout(() => resolve("slow"), 100))
        );

      // Start long operation
      const longPromise = testLockService.withLock(
        "timeout-key",
        longOperation
      );

      // Try to acquire same lock with short timeout
      await expect(
        testLockService.withLock(
          "timeout-key",
          () => Promise.resolve("fast"),
          50
        )
      ).rejects.toThrow("Lock timeout after 50ms for key: timeout-key");

      // Original operation should still complete
      const result = await longPromise;
      expect(result).toBe("slow");
    }, 15000); // 15 second timeout

    it("should use default timeout when not specified", async () => {
      const longOperation = vi
        .fn()
        .mockImplementation(
          () =>
            new Promise((resolve) => setTimeout(() => resolve("long"), 3000))
        );

      // Start long operation (3 seconds)
      const longPromise = testLockService.withLock(
        "default-timeout",
        longOperation
      );

      // Try to acquire same lock (should use default 5000ms timeout)
      const start = Date.now();
      await expect(
        testLockService.withLock("default-timeout", () =>
          Promise.resolve("quick")
        )
      ).rejects.toThrow("Lock timeout after 5000ms");

      const elapsed = Date.now() - start;
      expect(elapsed).toBeGreaterThan(4900); // Should wait close to 5 seconds
      expect(elapsed).toBeLessThan(5200);

            // Clean up
      await longPromise.catch(() => {});
    }, 15000); // 15 second timeout
    }, 15000); // 15 second timeout

    it("should handle custom timeout values", async () => {
      const mediumOperation = vi
        .fn()
        .mockImplementation(
          () =>
            new Promise((resolve) => setTimeout(() => resolve("medium"), 150))
        );

      // Start medium operation
      const mediumPromise = testLockService.withLock(
        "custom-timeout",
        mediumOperation
      );

      // Try with custom timeout that should fail
      await expect(
        testLockService.withLock(
          "custom-timeout",
          () => Promise.resolve("quick"),
          100
        )
      ).rejects.toThrow("Lock timeout after 100ms");

      // Try with custom timeout that should succeed
      const result = await testLockService.withLock(
        "custom-timeout",
        () => Promise.resolve("patient"),
        200
      );
      expect(result).toBe("patient");

      await mediumPromise; // Clean up
    }, 15000); // 15 second timeout
  });

  describe("Lock Statistics", () => {
    it("should track lock statistics correctly", async () => {
      const initialStats = testLockService.getLockStats();
      expect(initialStats.activeLocks).toBe(0);
      expect(initialStats.totalLocksAcquired).toBe(0);
      expect(initialStats.averageWaitTime).toBe(0);

      // Execute some operations
      await testLockService.withLock("stats1", () => Promise.resolve("test1"));
      await testLockService.withLock("stats2", () => Promise.resolve("test2"));

      const finalStats = testLockService.getLockStats();
      expect(finalStats.activeLocks).toBe(0); // Should be 0 after completion
      expect(finalStats.totalLocksAcquired).toBe(2);
      expect(finalStats.averageWaitTime).toBeGreaterThanOrEqual(0);
    });

    it("should show active locks during operation", async () => {
      // Reset stats before testing
      testLockService.clearAllLocks();

      const checkStatsOperation = vi.fn().mockImplementation(async () => {
        await new Promise((resolve) => setTimeout(resolve, 10));
        return "checked";
      });

      await testLockService.withLock("active-stats", checkStatsOperation);

      // Verify the operation was tracked in statistics
      const finalStats = testLockService.getLockStats();
      expect(finalStats.totalLocksAcquired).toBe(1);
      expect(finalStats.averageWaitTime).toBeGreaterThanOrEqual(0);
    }, 15000); // 15 second timeout

    it("should calculate average wait time correctly", async () => {
      // First operation - no wait
      await testLockService.withLock("avg-key", () => Promise.resolve("first"));

      // Second operation on different key - no wait
      await testLockService.withLock("avg-key2", () =>
        Promise.resolve("second")
      );

      const stats = testLockService.getLockStats();
      expect(stats.totalLocksAcquired).toBe(2);
      expect(stats.averageWaitTime).toBeGreaterThanOrEqual(0);
      expect(stats.averageWaitTime).toBeLessThan(50); // Should be very low for non-contended locks
    });
  });

  describe("Development Helper Methods", () => {
    it("should clear all locks in non-production environment", () => {
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = "development";

      // Should not throw in development
      expect(() => testLockService.clearAllLocks()).not.toThrow();

      process.env.NODE_ENV = originalEnv;
    });

    it("should prevent clearing locks in production", () => {
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = "production";

      expect(() => testLockService.clearAllLocks()).toThrow(
        "clearAllLocks() cannot be called in production"
      );

      process.env.NODE_ENV = originalEnv;
    });

    it("should actually clear locks when called", async () => {
      const originalEnv = process.env.NODE_ENV;
      process.env.NODE_ENV = "test";

      // Create some lock state
      await testLockService.withLock("clear-test", () =>
        Promise.resolve("test")
      );
      const statsBefore = testLockService.getLockStats();
      expect(statsBefore.totalLocksAcquired).toBe(1);

      // Clear should reset internal state
      testLockService.clearAllLocks();

      // Stats should still show history, but no active locks
      const statsAfter = testLockService.getLockStats();
      expect(statsAfter.activeLocks).toBe(0);

      process.env.NODE_ENV = originalEnv;
    });
  });

  describe("Edge Cases and Race Conditions", () => {
    it("should handle rapid successive operations on same key", async () => {
      const results: string[] = [];
      const operations = Array.from({ length: 5 }, (_, i) =>
        testLockService.withLock("rapid-key", async () => {
          const result = `op-${i}`;
          results.push(result);
          await new Promise((resolve) => setTimeout(resolve, 5));
          return result;
        })
      );

      const finalResults = await Promise.all(operations);

      expect(finalResults).toHaveLength(5);
      expect(results).toEqual(finalResults); // Results should be in execution order
      expect(new Set(results)).toHaveProperty("size", 5); // All unique
    }, 15000); // 15 second timeout

    it("should handle operations that complete immediately", async () => {
      const instantOperation = vi.fn().mockResolvedValue("instant");

      const result = await testLockService.withLock(
        "instant-key",
        instantOperation
      );

      expect(result).toBe("instant");
      expect(instantOperation).toHaveBeenCalledTimes(1);

      const stats = testLockService.getLockStats();
      expect(stats.activeLocks).toBe(0);
    });

    it("should handle mixed sync and async operations", async () => {
      const syncOperation = vi.fn().mockReturnValue(Promise.resolve("sync"));
      const asyncOperation = vi.fn().mockImplementation(async () => {
        await new Promise((resolve) => setTimeout(resolve, 10));
        return "async";
      });

      const syncResult = await testLockService.withLock(
        "mixed1",
        syncOperation
      );
      const asyncResult = await testLockService.withLock(
        "mixed2",
        asyncOperation
      );

      expect(syncResult).toBe("sync");
      expect(asyncResult).toBe("async");
    }, 15000); // 15 second timeout

    it("should handle operations with undefined return values", async () => {
      const undefinedOperation = vi.fn().mockResolvedValue(undefined);

      const result = await testLockService.withLock(
        "undefined-key",
        undefinedOperation
      );

      expect(result).toBeUndefined();
      expect(undefinedOperation).toHaveBeenCalledTimes(1);
    });
  });

  describe("Singleton Export", () => {
    it("should export a singleton instance", () => {
      expect(lockService).toBeInstanceOf(InMemoryLockService);
    });

    it("should be the same instance across imports", () => {
      // The exported lockService should be a singleton
      expect(lockService).toBe(lockService);
    });
  });

  describe("Real-world Event Signup Scenarios", () => {
    it("should handle event signup race conditions", async () => {
      let currentCapacity = 5;
      const maxCapacity = 5;
      const signupResults: string[] = [];

      const signupOperation = (userId: string) => async () => {
        // Simulate checking capacity and registering
        if (currentCapacity > 0) {
          currentCapacity--;
          await new Promise((resolve) => setTimeout(resolve, 5)); // Simulate DB operation
          signupResults.push(`${userId}-success`);
          return "success";
        } else {
          signupResults.push(`${userId}-failed`);
          throw new Error("Event full");
        }
      };

      // Simulate 10 users trying to sign up simultaneously for 5 spots
      const signupPromises = Array.from({ length: 10 }, (_, i) =>
        testLockService
          .withLock("signup:event123:role456", signupOperation(`user${i}`))
          .catch(() => "failed")
      );

      const results = await Promise.all(signupPromises);

      // Exactly 5 should succeed, 5 should fail
      const successful = results.filter((r) => r === "success");
      const failed = results.filter((r) => r === "failed");

      expect(successful).toHaveLength(5);
      expect(failed).toHaveLength(5);
      expect(currentCapacity).toBe(0);
    }, 15000); // 15 second timeout

    it("should handle different event role signups independently", async () => {
      const signupCounters = {
        "event1:role1": 0,
        "event1:role2": 0,
        "event2:role1": 0,
      };

      const createSignupOp = (eventRole: string) => async () => {
        signupCounters[eventRole as keyof typeof signupCounters]++;
        await new Promise((resolve) => setTimeout(resolve, 10));
        return `registered-${eventRole}`;
      };

      // Concurrent signups for different event:role combinations
      const promises = [
        testLockService.withLock(
          "signup:event1:role1",
          createSignupOp("event1:role1")
        ),
        testLockService.withLock(
          "signup:event1:role2",
          createSignupOp("event1:role2")
        ),
        testLockService.withLock(
          "signup:event2:role1",
          createSignupOp("event2:role1")
        ),
      ];

      const results = await Promise.all(promises);

      expect(results).toEqual([
        "registered-event1:role1",
        "registered-event1:role2",
        "registered-event2:role1",
      ]);

      // All should have executed (different lock keys)
      expect(signupCounters["event1:role1"]).toBe(1);
      expect(signupCounters["event1:role2"]).toBe(1);
      expect(signupCounters["event2:role1"]).toBe(1);
    }, 15000); // 15 second timeout
  });
});
});
