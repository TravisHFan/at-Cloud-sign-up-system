import { describe, it, expect, beforeEach, vi } from "vitest";
import { Request, Response } from "express";

// Mock all external dependencies first
const mockUserModel = {
  findOne: vi.fn(),
  create: vi.fn(),
  constructor: vi.fn(),
};

const mockTokenService = {
  generateTokenPair: vi.fn(),
};

const mockEmailService = {
  sendVerificationEmail: vi.fn(),
};

const mockUnifiedMessageController = {
  sendWelcomeNotification: vi.fn(),
};

const mockBcrypt = {
  hash: vi.fn(),
  compare: vi.fn(),
};

const mockCrypto = {
  randomBytes: vi.fn(),
};

// Mock implementations
vi.mock("../../../src/models", () => ({
  User: mockUserModel,
}));

vi.mock("../../../src/middleware/auth", () => ({
  TokenService: mockTokenService,
}));

vi.mock("../../../src/services/infrastructure/emailService", () => ({
  EmailService: mockEmailService,
}));

vi.mock("../../../src/services/infrastructure/autoEmailNotificationService", () => ({
  AutoEmailNotificationService: {
    sendAtCloudRoleChangeNotification: vi.fn(),
  },
}));

vi.mock("../../../src/controllers/unifiedMessageController", () => ({
  UnifiedMessageController: mockUnifiedMessageController,
}));

vi.mock("bcryptjs", () => mockBcrypt);
vi.mock("crypto", () => mockCrypto);

// Import after mocking
import { AuthController } from "../../../src/controllers/authController";

describe("AuthController", () => {
  let mockRequest: Partial<Request>;
  let mockResponse: Partial<Response>;
  let mockJson: any;
  let mockStatus: any;

  beforeEach(() => {
    vi.clearAllMocks();
    mockJson = vi.fn();
    mockStatus = vi.fn().mockReturnThis();
    
    mockResponse = {
      status: mockStatus,
      json: mockJson,
      cookie: vi.fn(),
      clearCookie: vi.fn(),
    };

    mockRequest = {
      body: {},
      params: {},
      query: {},
      user: undefined,
      headers: {},
    };

    // Reset mocks to default state before each test
    mockUserModel.findOne.mockReset();
    mockTokenService.generateTokenPair.mockReset();
    mockEmailService.sendVerificationEmail.mockReset();
    mockUnifiedMessageController.sendWelcomeNotification.mockReset();
  });

  describe("register", () => {
    it("should exist", async () => {
      expect(AuthController.register).toBeDefined();
      expect(typeof AuthController.register).toBe("function");
    });

    it("should successfully register a new user", async () => {
      // Arrange
      const validRegistrationData = {
        username: "testuser",
        email: "test@example.com",
        password: "TestPassword123!",
        confirmPassword: "TestPassword123!",
        firstName: "Test",
        lastName: "User",
        acceptTerms: true,
        isAtCloudLeader: false,
      };
      
      mockRequest.body = validRegistrationData;
      
      // Mock User.findOne to return null (no existing user)
      mockUserModel.findOne.mockResolvedValue(null);
      
      // Mock bcrypt and crypto
      mockBcrypt.hash.mockResolvedValue("hashedPassword123");
      mockCrypto.randomBytes.mockReturnValue(Buffer.from("verification123"));
      
      const mockUser = {
        _id: "user123",
        username: "testuser",
        email: "test@example.com",
        firstName: "Test",
        lastName: "User",
        save: vi.fn().mockResolvedValue(undefined),
        generateEmailVerificationToken: vi.fn().mockReturnValue("verification123"),
      };
      
      // Mock the User constructor
      mockUserModel.constructor = vi.fn().mockImplementation(() => mockUser);
      
      mockTokenService.generateTokenPair.mockReturnValue({
        accessToken: "access123",
        refreshToken: "refresh123",
        accessTokenExpires: new Date(),
        refreshTokenExpires: new Date(),
      });
      mockEmailService.sendVerificationEmail.mockResolvedValue(true);
      mockUnifiedMessageController.sendWelcomeNotification.mockResolvedValue(undefined);

      // Act
      await AuthController.register(mockRequest as Request, mockResponse as Response);

      // Assert
      expect(mockStatus).toHaveBeenCalledWith(201);
      expect(mockJson).toHaveBeenCalledWith(
        expect.objectContaining({
          success: true,
          message: expect.stringContaining("Registration successful"),
        })
      );
    });

    it("should reject registration with existing username", async () => {
      // Arrange
      mockRequest.body = {
        username: "testuser",
        email: "test@example.com",
        password: "TestPassword123!",
        confirmPassword: "TestPassword123!",
        firstName: "Test",
        lastName: "User",
        acceptTerms: true,
        isAtCloudLeader: false,
      };
      
      // Mock duplicate key error like MongoDB would throw
      const duplicateError = new Error("Duplicate key error");
      (duplicateError as any).code = 11000;
      (duplicateError as any).keyPattern = { username: 1 };
      
      const mockUser = {
        save: vi.fn().mockRejectedValue(duplicateError),
        generateEmailVerificationToken: vi.fn().mockReturnValue("verification123"),
      };
      
      mockUserModel.constructor = vi.fn().mockImplementation(() => mockUser);

      // Act
      await AuthController.register(mockRequest as Request, mockResponse as Response);

      // Assert
      expect(mockStatus).toHaveBeenCalledWith(409);
      expect(mockJson).toHaveBeenCalledWith(
        expect.objectContaining({
          success: false,
          message: expect.stringContaining("already"),
        })
      );
    });

    it("should reject registration with mismatched passwords", async () => {
      // Arrange
      mockRequest.body = {
        username: "testuser",
        email: "test@example.com",
        password: "TestPassword123!",
        confirmPassword: "DifferentPassword123!",
        firstName: "Test",
        lastName: "User",
        acceptTerms: true,
        isAtCloudLeader: false,
      };

      // Act
      await AuthController.register(mockRequest as Request, mockResponse as Response);

      // Assert
      expect(mockStatus).toHaveBeenCalledWith(400);
      expect(mockJson).toHaveBeenCalledWith(
        expect.objectContaining({
          success: false,
          message: "Passwords do not match",
        })
      );
    });
  });

  describe("login", () => {
    it("should exist", async () => {
      expect(AuthController.login).toBeDefined();
      expect(typeof AuthController.login).toBe("function");
    });
  });

  describe("logout", () => {
    it("should exist", async () => {
      expect(AuthController.logout).toBeDefined();
      expect(typeof AuthController.logout).toBe("function");
    });
  });

  describe("verifyEmail", () => {
    it("should exist", async () => {
      expect(AuthController.verifyEmail).toBeDefined();
      expect(typeof AuthController.verifyEmail).toBe("function");
    });
  });

  describe("forgotPassword", () => {
    it("should exist", async () => {
      expect(AuthController.forgotPassword).toBeDefined();
      expect(typeof AuthController.forgotPassword).toBe("function");
    });
  });

  describe("resetPassword", () => {
    it("should exist", async () => {
      expect(AuthController.resetPassword).toBeDefined();
      expect(typeof AuthController.resetPassword).toBe("function");
    });
  });

  describe("getProfile", () => {
    it("should exist", async () => {
      expect(AuthController.getProfile).toBeDefined();
      expect(typeof AuthController.getProfile).toBe("function");
    });
  });

  describe("refreshToken", () => {
    it("should exist", async () => {
      expect(AuthController.refreshToken).toBeDefined();
      expect(typeof AuthController.refreshToken).toBe("function");
    });
  });

  describe("resendVerification", () => {
    it("should exist", async () => {
      expect(AuthController.resendVerification).toBeDefined();
      expect(typeof AuthController.resendVerification).toBe("function");
    });
  });

  describe("requestPasswordChange", () => {
    it("should exist", async () => {
      expect(AuthController.requestPasswordChange).toBeDefined();
      expect(typeof AuthController.requestPasswordChange).toBe("function");
    });
  });

  describe("completePasswordChange", () => {
    it("should exist", async () => {
      expect(AuthController.completePasswordChange).toBeDefined();
      expect(typeof AuthController.completePasswordChange).toBe("function");
    });
  });
});