import mongoose, { Schema, Document } from "mongoose";

export interface IBillingInfo {
  fullName: string;
  email: string;
  address?: string;
  city?: string;
  state?: string;
  zipCode?: string;
  country?: string;
}

export interface IPaymentMethod {
  type: "card" | "other";
  cardBrand?: string; // e.g., "visa", "mastercard"
  last4?: string; // Last 4 digits of card
  cardholderName?: string;
}

export interface IPurchase extends Document {
  // Core purchase info
  userId: mongoose.Types.ObjectId;
  purchaseType: "program" | "event"; // Type of purchase: program enrollment or event ticket
  programId?: mongoose.Types.ObjectId; // Required if purchaseType = 'program'
  eventId?: mongoose.Types.ObjectId; // Required if purchaseType = 'event'
  orderNumber: string; // Unique order number (e.g., "ORD-20250114-XXXXX")

  // Pricing breakdown (all values in cents)
  fullPrice: number; // Original full price in cents (e.g., 9999 = $99.99)
  classRepDiscount: number; // Class Rep discount in cents (0 if not selected)
  earlyBirdDiscount: number; // Early Bird discount in cents (0 if not applicable)
  finalPrice: number; // Actual amount charged in cents (fullPrice - discounts)

  // Flags
  isClassRep: boolean; // Whether user selected Class Rep option
  isEarlyBird: boolean; // Whether Early Bird discount was applied

  // Promo code fields - code USED on this purchase
  promoCode?: string; // The promo code that was applied to this purchase
  promoCodeId?: mongoose.Types.ObjectId; // Reference to the promo code document
  promoDiscountAmount?: number; // Dollar discount from promo (in cents, e.g., 5000 = $50)
  promoDiscountPercent?: number; // Percentage discount from promo (0-100, for 100% staff codes)

  // Bundle promo fields - code GENERATED by this purchase
  bundlePromoCode?: string; // The bundle code generated for this purchase
  bundleDiscountAmount?: number; // Amount for the bundle code (in cents, e.g., 5000 = $50)
  bundleExpiresAt?: Date; // When the bundle code expires

  // Billing and payment
  billingInfo: IBillingInfo;
  paymentMethod: IPaymentMethod;

  // Stripe integration
  stripeSessionId?: string; // Stripe Checkout Session ID
  stripePaymentIntentId?: string; // Stripe Payment Intent ID

  // Status
  status:
    | "pending"
    | "completed"
    | "failed"
    | "refunded"
    | "refund_processing"
    | "refund_failed";

  // Refund tracking
  refundedAt?: Date; // When the refund was completed
  refundInitiatedAt?: Date; // When the refund was initiated
  refundFailureReason?: string; // Reason if refund failed
  stripeRefundId?: string; // Stripe Refund ID

  // Timestamps
  purchaseDate: Date; // When the purchase was completed
  createdAt: Date;
  updatedAt: Date;
}

const billingInfoSchema = new Schema<IBillingInfo>(
  {
    fullName: { type: String, required: true, trim: true, maxlength: 200 },
    email: {
      type: String,
      required: true,
      trim: true,
      lowercase: true,
      maxlength: 255,
    },
    address: { type: String, trim: true, maxlength: 500 },
    city: { type: String, trim: true, maxlength: 100 },
    state: { type: String, trim: true, maxlength: 100 },
    zipCode: { type: String, trim: true, maxlength: 20 },
    country: { type: String, trim: true, maxlength: 100 },
  },
  { _id: false }
);

const paymentMethodSchema = new Schema<IPaymentMethod>(
  {
    type: {
      type: String,
      required: true,
      enum: ["card", "other"],
      default: "card",
    },
    cardBrand: { type: String, trim: true, maxlength: 50 },
    last4: { type: String, trim: true, maxlength: 4 },
    cardholderName: { type: String, trim: true, maxlength: 200 },
  },
  { _id: false }
);

const purchaseSchema = new Schema<IPurchase>(
  {
    userId: {
      type: Schema.Types.ObjectId,
      ref: "User",
      required: true,
      index: true,
    },
    purchaseType: {
      type: String,
      required: true,
      enum: ["program", "event"],
      default: "program", // Default for backward compatibility with existing purchases
      index: true,
    },
    programId: {
      type: Schema.Types.ObjectId,
      ref: "Program",
      required: function (this: IPurchase) {
        return this.purchaseType === "program";
      },
      index: true,
    },
    eventId: {
      type: Schema.Types.ObjectId,
      ref: "Event",
      required: function (this: IPurchase) {
        return this.purchaseType === "event";
      },
      index: true,
    },
    orderNumber: {
      type: String,
      required: true,
      unique: true,
      trim: true,
      maxlength: 50,
    },
    fullPrice: {
      type: Number,
      required: true,
      min: 0,
      max: 100000, // 0-100000 cents ($0-$1000)
    },
    classRepDiscount: {
      type: Number,
      required: true,
      default: 0,
      min: 0,
      max: 100000, // 0-100000 cents ($0-$1000)
    },
    earlyBirdDiscount: {
      type: Number,
      required: true,
      default: 0,
      min: 0,
      max: 100000, // 0-100000 cents ($0-$1000)
    },
    finalPrice: {
      type: Number,
      required: true,
      min: 0,
      max: 100000, // 0-100000 cents ($0-$1000)
    },
    isClassRep: {
      type: Boolean,
      required: true,
      default: false,
    },
    isEarlyBird: {
      type: Boolean,
      required: true,
      default: false,
    },
    // Promo code fields - code USED on this purchase
    promoCode: {
      type: String,
      trim: true,
      maxlength: 20,
      index: true, // Index for searching by promo code
    },
    promoCodeId: {
      type: Schema.Types.ObjectId,
      ref: "PromoCode",
    },
    promoDiscountAmount: {
      type: Number,
      min: 0,
      max: 100000, // 0-100000 cents ($0-$1000)
    },
    promoDiscountPercent: {
      type: Number,
      min: 0,
      max: 100, // 0-100%
    },
    // Bundle promo fields - code GENERATED by this purchase
    bundlePromoCode: {
      type: String,
      trim: true,
      maxlength: 20,
    },
    bundleDiscountAmount: {
      type: Number,
      min: 0,
      max: 100000, // 0-100000 cents ($0-$1000)
    },
    bundleExpiresAt: {
      type: Date,
    },
    billingInfo: {
      type: billingInfoSchema,
      required: true,
    },
    paymentMethod: {
      type: paymentMethodSchema,
      required: true,
    },
    stripeSessionId: {
      type: String,
      trim: true,
      maxlength: 255,
      index: true,
    },
    stripePaymentIntentId: {
      type: String,
      trim: true,
      maxlength: 255,
    },
    status: {
      type: String,
      required: true,
      enum: [
        "pending",
        "completed",
        "failed",
        "refunded",
        "refund_processing",
        "refund_failed",
      ],
      default: "pending",
    },
    refundedAt: {
      type: Date,
    },
    refundInitiatedAt: {
      type: Date,
    },
    refundFailureReason: {
      type: String,
      trim: true,
      maxlength: 500,
    },
    stripeRefundId: {
      type: String,
      trim: true,
      maxlength: 255,
    },
    purchaseDate: {
      type: Date,
      required: true,
      default: Date.now,
    },
  },
  {
    timestamps: true,
    toJSON: {
      transform: function (
        _doc,
        ret: Record<string, unknown> & { _id?: unknown; __v?: unknown }
      ) {
        (ret as { id?: string }).id = ret._id as unknown as string;
        delete ret._id;
        delete ret.__v;
        return ret;
      },
    },
  }
);

// Compound index for efficient queries
purchaseSchema.index({ userId: 1, programId: 1 });
purchaseSchema.index({ status: 1, purchaseDate: -1 });

// Static method to generate unique order number
purchaseSchema.statics.generateOrderNumber =
  async function (): Promise<string> {
    const date = new Date();
    const dateStr = date.toISOString().split("T")[0].replace(/-/g, ""); // YYYYMMDD

    // Find the latest order number for today
    const prefix = `ORD-${dateStr}`;
    const latestOrder = await this.findOne({
      orderNumber: new RegExp(`^${prefix}`),
    }).sort({ orderNumber: -1 });

    let sequence = 1;
    if (latestOrder) {
      const match = latestOrder.orderNumber.match(/-(\d+)$/);
      if (match) {
        sequence = parseInt(match[1], 10) + 1;
      }
    }

    // Pad sequence to 5 digits
    const sequenceStr = sequence.toString().padStart(5, "0");
    return `${prefix}-${sequenceStr}`;
  };

// Use existing model if already compiled (fixes test re-import issues)
const Purchase =
  mongoose.models.Purchase ||
  mongoose.model<IPurchase>("Purchase", purchaseSchema);

export default Purchase;
